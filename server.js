// Generated by CoffeeScript 1.3.3
(function() {
  var MongoStore, app, async, chbs, cleans, colors, connect, curses, cussFilter, ensureSession, express, fs, io, models, online, os, package_info, pwh, secrets, sessionStore, socketio, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require("underscore");

  fs = require("fs");

  os = require("os");

  pwh = require("password-hash");

  chbs = require("connect-handlebars");

  async = require("async");

  colors = require("colors");

  connect = require("connect");

  express = require("express");

  socketio = require("socket.io");

  MongoStore = require("connect-mongo")(express);

  models = require("./models");

  secrets = require("./secrets");

  package_info = JSON.parse(fs.readFileSync("" + __dirname + "/package.json", "utf-8"));

  app = express.createServer();

  io = socketio.listen(app);

  sessionStore = new MongoStore({
    db: 'keeba',
    url: secrets.MONGO_URI,
    stringify: false,
    clear_interval: 432000
  }, function() {
    app.listen(process.env.PORT || 7331);
    console.log("   ---------".red);
    console.log("   | VE RI |".red);
    console.log("    \\ TAS /".red);
    return console.log("     \\___/".red);
  });

  online = {};

  app.configure(function() {
    app.use(express.cookieParser());
    app.use(express.bodyParser());
    app.use(express.session({
      store: sessionStore,
      secret: secrets.SESSION_SECRET,
      key: "express.sid"
    }));
    app.use(app.router);
    app.use(express["static"]("" + __dirname + "/static"));
    app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
    app.use("/js/templates.js", chbs("" + __dirname + "/templates", {
      exts: ['hbs']
    }));
    app.set('jsonp callback');
    app.set('view engine', 'jade');
    app.set('views', "" + __dirname + "/views");
    return app.use(express.limit('1mb'));
  });

  app.dynamicHelpers({
    version: function(req, res) {
      return package_info.version;
    }
  });

  ensureSession = function(req, res, next) {
    if (!req.session.username) {
      return res.redirect("/?whence=" + req.url);
    } else {
      return next();
    }
  };

  app.get("/", function(req, res) {
    if (req.session.username) {
      return res.redirect("/lounge");
    } else {
      return res.render("index", {
        appmode: false
      });
    }
  });

  app.get("/what", function(req, res) {
    return res.render("what", {
      appmode: req.session.username
    });
  });

  app.get("/who", function(req, res) {
    return res.render("who", {
      appmode: req.session.username
    });
  });

  app.get("/up", function(req, res) {
    if (req.session.username) {
      return res.redirect("/lounge");
    } else {
      return res.render("up", {
        appmode: false,
        failed: false,
        dorms: models.DORMS,
        dorm: '',
        notevil: '',
        ovaries: '',
        username: '',
        hid: ''
      });
    }
  });

  app.post("/up", function(req, res) {
    var dorm, fail, hid, notevil, ovaries, password1, password2, person, username;
    hid = req.body.hid || '';
    username = req.body.username;
    password1 = req.body.password1;
    password2 = req.body.password2;
    ovaries = req.body.ovaries;
    dorm = req.body.dorm;
    notevil = req.body.notevil;
    fail = function() {
      return res.render("up", {
        appmode: false,
        failed: true,
        dorms: models.DORMS,
        hid: hid,
        dorm: dorm,
        notevil: notevil,
        ovaries: ovaries,
        username: username
      });
    };
    if (password1 !== password2) {
      return fail();
    } else if (username < 5 || username > 18) {
      return fail();
    } else if (password1.length < 5) {
      return fail();
    } else if (__indexOf.call(username, " ") >= 0) {
      return fail();
    } else if (_.isUndefined(notevil)) {
      return fail();
    } else if (__indexOf.call(models.DORMS, dorm) < 0) {
      return fail();
    } else if (hid.slice(3, 5) !== "66" || hid.length !== 8) {
      return fail();
    } else {
      person = new models.Person();
      person.hid = Number(hid);
      person.username = username;
      if (ovaries) {
        person.ovaries = true;
      } else {
        person.ovaries = false;
      }
      person.password = password1;
      person.dorm = dorm;
      return person.save(function(err) {
        if (err) {
          console.log(err);
          return fail();
        } else {
          req.session.username = username;
          return res.redirect("/lounge");
        }
      });
    }
  });

  app.get("/in", function(req, res) {
    return res.render("in", {
      appmode: false,
      failed: false,
      username: ''
    });
  });

  app.post("/in", function(req, res) {
    var fail, password, username;
    username = req.body.username || '';
    password = req.body.password;
    fail = function() {
      return res.render("in", {
        appmode: false,
        failed: true,
        username: username
      });
    };
    return models.Person.findOne().where("username", username).run(function(err, person) {
      if (err || !person) {
        return fail();
      } else {
        if (pwh.verify(password, person.password)) {
          req.session.username = username;
          return res.redirect("/lounge");
        } else {
          return fail();
        }
      }
    });
  });

  app.get("/out", function(req, res) {
    req.session.destroy();
    return res.redirect("/");
  });

  app.post("/validate", function(req, res) {
    var hid;
    hid = req.body.hid;
    if (hid.slice(3, 5) === "66" && hid.length === 8) {
      return res.send("OK");
    } else {
      return res.send("BUT SIRRR");
    }
  });

  app.post("/username", function(req, res) {
    var username;
    username = req.body.username;
    return models.Person.findOne().where("username", username).run(function(err, person) {
      if (person) {
        return res.send("umad?");
      } else {
        return res.send("OK");
      }
    });
  });

  app.get("/people/:id", ensureSession, function(req, res) {
    var id;
    if (req.params.id === "me") {
      id = req.session.username;
    } else {
      id = req.params.id;
    }
    return models.Person.findOne().where("username", id).populate("groups").run(function(err, person) {
      if (err || !person) {
        return res.render("error", {
          appmode: false
        });
      } else {
        return res.render("person", {
          appmode: true,
          person: person
        });
      }
    });
  });

  app.post("/people/:id", ensureSession, function(req, res) {
    return res.render("person", {
      appmode: true
    });
  });

  app.get("/lounge*", ensureSession, function(req, res) {
    var username;
    username = req.session.username;
    return async.parallel([
      function(cb) {
        return models.Group.find().populate("members", ["username"]).run(cb);
      }
    ], function(err, results) {
      var _online;
      if (err) {
        return res.render("error");
      } else {
        _online = _.clone(online);
        if (!_.has(_online, username)) {
          _online[username] = 1;
        }
        return res.render("lounge", {
          appmode: true,
          groups_bootstrap: JSON.stringify(results[0]),
          online: JSON.stringify(_.keys(_online))
        });
      }
    });
  });

  curses = ["fuck", "shit", "bitch", "douche", "cock", "fag", "faggot", "nigger", "cunt", "whore", "ass", "dick", "penis", "vagina", "pussy", "tits"];

  cleans = ["squidward", "jigglypuff", "trollface", "cowsaysmoo", "soap", "AGNRY FAIC", "Sarah Palin", "N00t G1ngr1ch", "l.o.l", "$#&!*#$*@&!&$", "pikachu", "creampuffs", "mushrooms", "Kleenex", "POLAR BEARS", "OVER 9000", "supersain", "deep", "BUT SIRRR", "DEEEEEEEEEEEEEEP", "GREAT SUCCESS", "chair", "ductape", "agua", "חביטאח", "watermellon", "Wal-Mart", "EXCEELLLENT", "thorax", "timmy", "James", "bob saget"];

  cussFilter = function(text) {
    var curse, pattern, _i, _len;
    for (_i = 0, _len = curses.length; _i < _len; _i++) {
      curse = curses[_i];
      pattern = new RegExp(curse, 'gi');
      text = text.replace(pattern, cleans[Math.floor(Math.random() * cleans.length)]);
    }
    return text;
  };

  io.set("authorization", function(data, accept) {
    if (data.headers.cookie) {
      data.cookie = connect.utils.parseCookie(data.headers.cookie);
      data.sessionID = data.cookie['express.sid'];
      data.sessionStore = sessionStore;
      return sessionStore.get(data.sessionID, function(err, session) {
        if (err) {
          return accept(err.message.toString(), false);
        } else {
          data.session = new connect.middleware.session.Session(data, session);
          return accept(null, true);
        }
      });
    } else {
      return accept("No cookie transmitted.", false);
    }
  });

  io.sockets.on("connection", function(socket) {
    var sync, username;
    username = socket.handshake.session.username;
    socket.join(username);
    if (_.has(online, username)) {
      online[username]++;
    } else {
      online[username] = 1;
    }
    socket.broadcast.emit("online", _.keys(online));
    sync = function(model, method, data) {
      var event_name;
      event_name = "" + model + "/" + data._id + ":" + method;
      return io.sockets.emit(event_name, data);
    };
    socket.on("group:create", function(data, cb) {
      return async.waterfall([
        function(wf_callback) {
          return models.Person.findOne().where("username", username).run(wf_callback);
        }, function(account, wf_callback) {
          var group;
          group = new models.Group();
          group.name = data.name;
          group.members.push(account);
          return group.save(function(err, group) {
            return wf_callback(err, account, group);
          });
        }, function(account, group, wf_callback) {
          account.groups.push(group);
          return account.save(function(err, account) {
            return wf_callback(err, group);
          });
        }
      ], function(err, group) {
        socket.broadcast.emit("groups:add", group);
        return cb(err, group);
      });
    });
    socket.on("group:message", function(group_id, body, cb) {
      return async.waterfall([
        function(wf_callback) {
          return models.Group.findOne().where("_id", group_id).run(wf_callback);
        }, function(group, wf_callback) {
          var message;
          message = {
            username: username,
            body: cussFilter(body)
          };
          group.messages.push(message);
          return group.save(function(err) {
            return wf_callback(err, group, message);
          });
        }
      ], function(err, group, message) {
        io.sockets.emit("message", {
          message: message,
          group: group._id
        });
        return cb(err);
      });
    });
    return socket.on("disconnect", function() {
      online[username]--;
      if (online[username] === 0) {
        delete online[username];
      }
      return socket.broadcast.emit("online", _.keys(online));
    });
  });

}).call(this);
